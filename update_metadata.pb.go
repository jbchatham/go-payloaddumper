// Code generated by protoc-gen-go. DO NOT EDIT.
// source: update_metadata.proto

/*
Package chromeos_update_engine is a generated protocol buffer package.

It is generated from these files:
	update_metadata.proto

It has these top-level messages:
	Extent
	Signatures
	PartitionInfo
	ImageInfo
	InstallOperation
	PartitionUpdate
	DynamicPartitionGroup
	DynamicPartitionMetadata
	DeltaArchiveManifest
*/
//package chromeos_update_engine
package main

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type InstallOperation_Type int32

const (
	InstallOperation_REPLACE    InstallOperation_Type = 0
	InstallOperation_REPLACE_BZ InstallOperation_Type = 1
	InstallOperation_MOVE       InstallOperation_Type = 2
	InstallOperation_BSDIFF     InstallOperation_Type = 3
	// On minor version 2 or newer, these operations are supported:
	InstallOperation_SOURCE_COPY   InstallOperation_Type = 4
	InstallOperation_SOURCE_BSDIFF InstallOperation_Type = 5
	// On minor version 3 or newer and on major version 2 or newer, these
	// operations are supported:
	InstallOperation_REPLACE_XZ InstallOperation_Type = 8
	// On minor version 4 or newer, these operations are supported:
	InstallOperation_ZERO          InstallOperation_Type = 6
	InstallOperation_DISCARD       InstallOperation_Type = 7
	InstallOperation_BROTLI_BSDIFF InstallOperation_Type = 10
	// On minor version 5 or newer, these operations are supported:
	InstallOperation_PUFFDIFF InstallOperation_Type = 9
)

var InstallOperation_Type_name = map[int32]string{
	0:  "REPLACE",
	1:  "REPLACE_BZ",
	2:  "MOVE",
	3:  "BSDIFF",
	4:  "SOURCE_COPY",
	5:  "SOURCE_BSDIFF",
	8:  "REPLACE_XZ",
	6:  "ZERO",
	7:  "DISCARD",
	10: "BROTLI_BSDIFF",
	9:  "PUFFDIFF",
}
var InstallOperation_Type_value = map[string]int32{
	"REPLACE":       0,
	"REPLACE_BZ":    1,
	"MOVE":          2,
	"BSDIFF":        3,
	"SOURCE_COPY":   4,
	"SOURCE_BSDIFF": 5,
	"REPLACE_XZ":    8,
	"ZERO":          6,
	"DISCARD":       7,
	"BROTLI_BSDIFF": 10,
	"PUFFDIFF":      9,
}

func (x InstallOperation_Type) Enum() *InstallOperation_Type {
	p := new(InstallOperation_Type)
	*p = x
	return p
}
func (x InstallOperation_Type) String() string {
	return proto.EnumName(InstallOperation_Type_name, int32(x))
}
func (x *InstallOperation_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(InstallOperation_Type_value, data, "InstallOperation_Type")
	if err != nil {
		return err
	}
	*x = InstallOperation_Type(value)
	return nil
}
func (InstallOperation_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

type Extent struct {
	StartBlock       *uint64 `protobuf:"varint,1,opt,name=start_block,json=startBlock" json:"start_block,omitempty"`
	NumBlocks        *uint64 `protobuf:"varint,2,opt,name=num_blocks,json=numBlocks" json:"num_blocks,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Extent) Reset()                    { *m = Extent{} }
func (m *Extent) String() string            { return proto.CompactTextString(m) }
func (*Extent) ProtoMessage()               {}
func (*Extent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Extent) GetStartBlock() uint64 {
	if m != nil && m.StartBlock != nil {
		return *m.StartBlock
	}
	return 0
}

func (m *Extent) GetNumBlocks() uint64 {
	if m != nil && m.NumBlocks != nil {
		return *m.NumBlocks
	}
	return 0
}

type Signatures struct {
	Signatures       []*Signatures_Signature `protobuf:"bytes,1,rep,name=signatures" json:"signatures,omitempty"`
	XXX_unrecognized []byte                  `json:"-"`
}

func (m *Signatures) Reset()                    { *m = Signatures{} }
func (m *Signatures) String() string            { return proto.CompactTextString(m) }
func (*Signatures) ProtoMessage()               {}
func (*Signatures) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Signatures) GetSignatures() []*Signatures_Signature {
	if m != nil {
		return m.Signatures
	}
	return nil
}

type Signatures_Signature struct {
	Version *uint32 `protobuf:"varint,1,opt,name=version" json:"version,omitempty"`
	Data    []byte  `protobuf:"bytes,2,opt,name=data" json:"data,omitempty"`
	// The DER encoded signature size of EC keys is nondeterministic for
	// different input of sha256 hash. However, we need the size of the
	// serialized signatures protobuf string to be fixed before signing;
	// because this size is part of the content to be signed. Therefore, we
	// always pad the signature data to the maximum possible signature size of
	// a given key. And the payload verifier will truncate the signature to
	// its correct size based on the value of |unpadded_signature_size|.
	UnpaddedSignatureSize *uint32 `protobuf:"fixed32,3,opt,name=unpadded_signature_size,json=unpaddedSignatureSize" json:"unpadded_signature_size,omitempty"`
	XXX_unrecognized      []byte  `json:"-"`
}

func (m *Signatures_Signature) Reset()                    { *m = Signatures_Signature{} }
func (m *Signatures_Signature) String() string            { return proto.CompactTextString(m) }
func (*Signatures_Signature) ProtoMessage()               {}
func (*Signatures_Signature) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 0} }

func (m *Signatures_Signature) GetVersion() uint32 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

func (m *Signatures_Signature) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Signatures_Signature) GetUnpaddedSignatureSize() uint32 {
	if m != nil && m.UnpaddedSignatureSize != nil {
		return *m.UnpaddedSignatureSize
	}
	return 0
}

type PartitionInfo struct {
	Size             *uint64 `protobuf:"varint,1,opt,name=size" json:"size,omitempty"`
	Hash             []byte  `protobuf:"bytes,2,opt,name=hash" json:"hash,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *PartitionInfo) Reset()                    { *m = PartitionInfo{} }
func (m *PartitionInfo) String() string            { return proto.CompactTextString(m) }
func (*PartitionInfo) ProtoMessage()               {}
func (*PartitionInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *PartitionInfo) GetSize() uint64 {
	if m != nil && m.Size != nil {
		return *m.Size
	}
	return 0
}

func (m *PartitionInfo) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

// Describe an image we are based on in a human friendly way.
// Examples:
//   dev-channel, x86-alex, 1.2.3, mp-v3
//   nplusone-channel, x86-alex, 1.2.4, mp-v3, dev-channel, 1.2.3
//
// All fields will be set, if this message is present.
type ImageInfo struct {
	Board   *string `protobuf:"bytes,1,opt,name=board" json:"board,omitempty"`
	Key     *string `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
	Channel *string `protobuf:"bytes,3,opt,name=channel" json:"channel,omitempty"`
	Version *string `protobuf:"bytes,4,opt,name=version" json:"version,omitempty"`
	// If these values aren't present, they should be assumed to match
	// the equivalent value above. They are normally only different for
	// special image types such as nplusone images.
	BuildChannel     *string `protobuf:"bytes,5,opt,name=build_channel,json=buildChannel" json:"build_channel,omitempty"`
	BuildVersion     *string `protobuf:"bytes,6,opt,name=build_version,json=buildVersion" json:"build_version,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ImageInfo) Reset()                    { *m = ImageInfo{} }
func (m *ImageInfo) String() string            { return proto.CompactTextString(m) }
func (*ImageInfo) ProtoMessage()               {}
func (*ImageInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ImageInfo) GetBoard() string {
	if m != nil && m.Board != nil {
		return *m.Board
	}
	return ""
}

func (m *ImageInfo) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *ImageInfo) GetChannel() string {
	if m != nil && m.Channel != nil {
		return *m.Channel
	}
	return ""
}

func (m *ImageInfo) GetVersion() string {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return ""
}

func (m *ImageInfo) GetBuildChannel() string {
	if m != nil && m.BuildChannel != nil {
		return *m.BuildChannel
	}
	return ""
}

func (m *ImageInfo) GetBuildVersion() string {
	if m != nil && m.BuildVersion != nil {
		return *m.BuildVersion
	}
	return ""
}

type InstallOperation struct {
	Type *InstallOperation_Type `protobuf:"varint,1,req,name=type,enum=chromeos_update_engine.InstallOperation_Type" json:"type,omitempty"`
	// Only minor version 6 or newer support 64 bits |data_offset| and
	// |data_length|, older client will read them as uint32.
	// The offset into the delta file (after the protobuf)
	// where the data (if any) is stored
	DataOffset *uint64 `protobuf:"varint,2,opt,name=data_offset,json=dataOffset" json:"data_offset,omitempty"`
	// The length of the data in the delta file
	DataLength *uint64 `protobuf:"varint,3,opt,name=data_length,json=dataLength" json:"data_length,omitempty"`
	// Ordered list of extents that are read from (if any) and written to.
	SrcExtents []*Extent `protobuf:"bytes,4,rep,name=src_extents,json=srcExtents" json:"src_extents,omitempty"`
	// Byte length of src, equal to the number of blocks in src_extents *
	// block_size. It is used for BSDIFF and SOURCE_BSDIFF, because we need to
	// pass that external program the number of bytes to read from the blocks we
	// pass it.  This is not used in any other operation.
	SrcLength  *uint64   `protobuf:"varint,5,opt,name=src_length,json=srcLength" json:"src_length,omitempty"`
	DstExtents []*Extent `protobuf:"bytes,6,rep,name=dst_extents,json=dstExtents" json:"dst_extents,omitempty"`
	// Byte length of dst, equal to the number of blocks in dst_extents *
	// block_size. Used for BSDIFF and SOURCE_BSDIFF, but not in any other
	// operation.
	DstLength *uint64 `protobuf:"varint,7,opt,name=dst_length,json=dstLength" json:"dst_length,omitempty"`
	// Optional SHA 256 hash of the blob associated with this operation.
	// This is used as a primary validation for http-based downloads and
	// as a defense-in-depth validation for https-based downloads. If
	// the operation doesn't refer to any blob, this field will have
	// zero bytes.
	DataSha256Hash []byte `protobuf:"bytes,8,opt,name=data_sha256_hash,json=dataSha256Hash" json:"data_sha256_hash,omitempty"`
	// Indicates the SHA 256 hash of the source data referenced in src_extents at
	// the time of applying the operation. If present, the update_engine daemon
	// MUST read and verify the source data before applying the operation.
	SrcSha256Hash    []byte `protobuf:"bytes,9,opt,name=src_sha256_hash,json=srcSha256Hash" json:"src_sha256_hash,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *InstallOperation) Reset()                    { *m = InstallOperation{} }
func (m *InstallOperation) String() string            { return proto.CompactTextString(m) }
func (*InstallOperation) ProtoMessage()               {}
func (*InstallOperation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *InstallOperation) GetType() InstallOperation_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return InstallOperation_REPLACE
}

func (m *InstallOperation) GetDataOffset() uint64 {
	if m != nil && m.DataOffset != nil {
		return *m.DataOffset
	}
	return 0
}

func (m *InstallOperation) GetDataLength() uint64 {
	if m != nil && m.DataLength != nil {
		return *m.DataLength
	}
	return 0
}

func (m *InstallOperation) GetSrcExtents() []*Extent {
	if m != nil {
		return m.SrcExtents
	}
	return nil
}

func (m *InstallOperation) GetSrcLength() uint64 {
	if m != nil && m.SrcLength != nil {
		return *m.SrcLength
	}
	return 0
}

func (m *InstallOperation) GetDstExtents() []*Extent {
	if m != nil {
		return m.DstExtents
	}
	return nil
}

func (m *InstallOperation) GetDstLength() uint64 {
	if m != nil && m.DstLength != nil {
		return *m.DstLength
	}
	return 0
}

func (m *InstallOperation) GetDataSha256Hash() []byte {
	if m != nil {
		return m.DataSha256Hash
	}
	return nil
}

func (m *InstallOperation) GetSrcSha256Hash() []byte {
	if m != nil {
		return m.SrcSha256Hash
	}
	return nil
}

// Describes the update to apply to a single partition.
type PartitionUpdate struct {
	// A platform-specific name to identify the partition set being updated. For
	// example, in Chrome OS this could be "ROOT" or "KERNEL".
	PartitionName *string `protobuf:"bytes,1,req,name=partition_name,json=partitionName" json:"partition_name,omitempty"`
	// Whether this partition carries a filesystem with post-install program that
	// must be run to finalize the update process. See also |postinstall_path| and
	// |filesystem_type|.
	RunPostinstall *bool `protobuf:"varint,2,opt,name=run_postinstall,json=runPostinstall" json:"run_postinstall,omitempty"`
	// The path of the executable program to run during the post-install step,
	// relative to the root of this filesystem. If not set, the default "postinst"
	// will be used. This setting is only used when |run_postinstall| is set and
	// true.
	PostinstallPath *string `protobuf:"bytes,3,opt,name=postinstall_path,json=postinstallPath" json:"postinstall_path,omitempty"`
	// The filesystem type as passed to the mount(2) syscall when mounting the new
	// filesystem to run the post-install program. If not set, a fixed list of
	// filesystems will be attempted. This setting is only used if
	// |run_postinstall| is set and true.
	FilesystemType *string `protobuf:"bytes,4,opt,name=filesystem_type,json=filesystemType" json:"filesystem_type,omitempty"`
	// If present, a list of signatures of the new_partition_info.hash signed with
	// different keys. If the update_engine daemon requires vendor-signed images
	// and has its public key installed, one of the signatures should be valid
	// for /postinstall to run.
	NewPartitionSignature []*Signatures_Signature `protobuf:"bytes,5,rep,name=new_partition_signature,json=newPartitionSignature" json:"new_partition_signature,omitempty"`
	OldPartitionInfo      *PartitionInfo          `protobuf:"bytes,6,opt,name=old_partition_info,json=oldPartitionInfo" json:"old_partition_info,omitempty"`
	NewPartitionInfo      *PartitionInfo          `protobuf:"bytes,7,opt,name=new_partition_info,json=newPartitionInfo" json:"new_partition_info,omitempty"`
	// The list of operations to be performed to apply this PartitionUpdate. The
	// associated operation blobs (in operations[i].data_offset, data_length)
	// should be stored contiguously and in the same order.
	Operations []*InstallOperation `protobuf:"bytes,8,rep,name=operations" json:"operations,omitempty"`
	// Whether a failure in the postinstall step for this partition should be
	// ignored.
	PostinstallOptional *bool `protobuf:"varint,9,opt,name=postinstall_optional,json=postinstallOptional" json:"postinstall_optional,omitempty"`
	// The extent for data covered by verity hash tree.
	HashTreeDataExtent *Extent `protobuf:"bytes,10,opt,name=hash_tree_data_extent,json=hashTreeDataExtent" json:"hash_tree_data_extent,omitempty"`
	// The extent to store verity hash tree.
	HashTreeExtent *Extent `protobuf:"bytes,11,opt,name=hash_tree_extent,json=hashTreeExtent" json:"hash_tree_extent,omitempty"`
	// The hash algorithm used in verity hash tree.
	HashTreeAlgorithm *string `protobuf:"bytes,12,opt,name=hash_tree_algorithm,json=hashTreeAlgorithm" json:"hash_tree_algorithm,omitempty"`
	// The salt used for verity hash tree.
	HashTreeSalt []byte `protobuf:"bytes,13,opt,name=hash_tree_salt,json=hashTreeSalt" json:"hash_tree_salt,omitempty"`
	// The extent for data covered by FEC.
	FecDataExtent *Extent `protobuf:"bytes,14,opt,name=fec_data_extent,json=fecDataExtent" json:"fec_data_extent,omitempty"`
	// The extent to store FEC.
	FecExtent *Extent `protobuf:"bytes,15,opt,name=fec_extent,json=fecExtent" json:"fec_extent,omitempty"`
	// The number of FEC roots.
	FecRoots         *uint32 `protobuf:"varint,16,opt,name=fec_roots,json=fecRoots,def=2" json:"fec_roots,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *PartitionUpdate) Reset()                    { *m = PartitionUpdate{} }
func (m *PartitionUpdate) String() string            { return proto.CompactTextString(m) }
func (*PartitionUpdate) ProtoMessage()               {}
func (*PartitionUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

const Default_PartitionUpdate_FecRoots uint32 = 2

func (m *PartitionUpdate) GetPartitionName() string {
	if m != nil && m.PartitionName != nil {
		return *m.PartitionName
	}
	return ""
}

func (m *PartitionUpdate) GetRunPostinstall() bool {
	if m != nil && m.RunPostinstall != nil {
		return *m.RunPostinstall
	}
	return false
}

func (m *PartitionUpdate) GetPostinstallPath() string {
	if m != nil && m.PostinstallPath != nil {
		return *m.PostinstallPath
	}
	return ""
}

func (m *PartitionUpdate) GetFilesystemType() string {
	if m != nil && m.FilesystemType != nil {
		return *m.FilesystemType
	}
	return ""
}

func (m *PartitionUpdate) GetNewPartitionSignature() []*Signatures_Signature {
	if m != nil {
		return m.NewPartitionSignature
	}
	return nil
}

func (m *PartitionUpdate) GetOldPartitionInfo() *PartitionInfo {
	if m != nil {
		return m.OldPartitionInfo
	}
	return nil
}

func (m *PartitionUpdate) GetNewPartitionInfo() *PartitionInfo {
	if m != nil {
		return m.NewPartitionInfo
	}
	return nil
}

func (m *PartitionUpdate) GetOperations() []*InstallOperation {
	if m != nil {
		return m.Operations
	}
	return nil
}

func (m *PartitionUpdate) GetPostinstallOptional() bool {
	if m != nil && m.PostinstallOptional != nil {
		return *m.PostinstallOptional
	}
	return false
}

func (m *PartitionUpdate) GetHashTreeDataExtent() *Extent {
	if m != nil {
		return m.HashTreeDataExtent
	}
	return nil
}

func (m *PartitionUpdate) GetHashTreeExtent() *Extent {
	if m != nil {
		return m.HashTreeExtent
	}
	return nil
}

func (m *PartitionUpdate) GetHashTreeAlgorithm() string {
	if m != nil && m.HashTreeAlgorithm != nil {
		return *m.HashTreeAlgorithm
	}
	return ""
}

func (m *PartitionUpdate) GetHashTreeSalt() []byte {
	if m != nil {
		return m.HashTreeSalt
	}
	return nil
}

func (m *PartitionUpdate) GetFecDataExtent() *Extent {
	if m != nil {
		return m.FecDataExtent
	}
	return nil
}

func (m *PartitionUpdate) GetFecExtent() *Extent {
	if m != nil {
		return m.FecExtent
	}
	return nil
}

func (m *PartitionUpdate) GetFecRoots() uint32 {
	if m != nil && m.FecRoots != nil {
		return *m.FecRoots
	}
	return Default_PartitionUpdate_FecRoots
}

type DynamicPartitionGroup struct {
	// Name of the group.
	Name *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	// Maximum size of the group. The sum of sizes of all partitions in the group
	// must not exceed the maximum size of the group.
	Size *uint64 `protobuf:"varint,2,opt,name=size" json:"size,omitempty"`
	// A list of partitions that belong to the group.
	PartitionNames   []string `protobuf:"bytes,3,rep,name=partition_names,json=partitionNames" json:"partition_names,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *DynamicPartitionGroup) Reset()                    { *m = DynamicPartitionGroup{} }
func (m *DynamicPartitionGroup) String() string            { return proto.CompactTextString(m) }
func (*DynamicPartitionGroup) ProtoMessage()               {}
func (*DynamicPartitionGroup) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *DynamicPartitionGroup) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *DynamicPartitionGroup) GetSize() uint64 {
	if m != nil && m.Size != nil {
		return *m.Size
	}
	return 0
}

func (m *DynamicPartitionGroup) GetPartitionNames() []string {
	if m != nil {
		return m.PartitionNames
	}
	return nil
}

// Metadata related to all dynamic partitions.
type DynamicPartitionMetadata struct {
	// All updatable groups present in |partitions| of this DeltaArchiveManifest.
	// - If an updatable group is on the device but not in the manifest, it is
	//   not updated. Hence, the group will not be resized, and partitions cannot
	//   be added to or removed from the group.
	// - If an updatable group is in the manifest but not on the device, the group
	//   is added to the device.
	Groups []*DynamicPartitionGroup `protobuf:"bytes,1,rep,name=groups" json:"groups,omitempty"`
	// Whether dynamic partitions have snapshots during the update. If this is
	// set to true, the update_engine daemon creates snapshots for all dynamic
	// partitions if possible. If this is unset, the update_engine daemon MUST
	// NOT create snapshots for dynamic partitions.
	SnapshotEnabled  *bool  `protobuf:"varint,2,opt,name=snapshot_enabled,json=snapshotEnabled" json:"snapshot_enabled,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *DynamicPartitionMetadata) Reset()                    { *m = DynamicPartitionMetadata{} }
func (m *DynamicPartitionMetadata) String() string            { return proto.CompactTextString(m) }
func (*DynamicPartitionMetadata) ProtoMessage()               {}
func (*DynamicPartitionMetadata) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *DynamicPartitionMetadata) GetGroups() []*DynamicPartitionGroup {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *DynamicPartitionMetadata) GetSnapshotEnabled() bool {
	if m != nil && m.SnapshotEnabled != nil {
		return *m.SnapshotEnabled
	}
	return false
}

type DeltaArchiveManifest struct {
	// Only present in major version = 1. List of install operations for the
	// kernel and rootfs partitions. For major version = 2 see the |partitions|
	// field.
	InstallOperations       []*InstallOperation `protobuf:"bytes,1,rep,name=install_operations,json=installOperations" json:"install_operations,omitempty"`
	KernelInstallOperations []*InstallOperation `protobuf:"bytes,2,rep,name=kernel_install_operations,json=kernelInstallOperations" json:"kernel_install_operations,omitempty"`
	// (At time of writing) usually 4096
	BlockSize *uint32 `protobuf:"varint,3,opt,name=block_size,json=blockSize,def=4096" json:"block_size,omitempty"`
	// If signatures are present, the offset into the blobs, generally
	// tacked onto the end of the file, and the length. We use an offset
	// rather than a bool to allow for more flexibility in future file formats.
	// If either is absent, it means signatures aren't supported in this
	// file.
	SignaturesOffset *uint64 `protobuf:"varint,4,opt,name=signatures_offset,json=signaturesOffset" json:"signatures_offset,omitempty"`
	SignaturesSize   *uint64 `protobuf:"varint,5,opt,name=signatures_size,json=signaturesSize" json:"signatures_size,omitempty"`
	// Only present in major version = 1. Partition metadata used to validate the
	// update. For major version = 2 see the |partitions| field.
	OldKernelInfo *PartitionInfo `protobuf:"bytes,6,opt,name=old_kernel_info,json=oldKernelInfo" json:"old_kernel_info,omitempty"`
	NewKernelInfo *PartitionInfo `protobuf:"bytes,7,opt,name=new_kernel_info,json=newKernelInfo" json:"new_kernel_info,omitempty"`
	OldRootfsInfo *PartitionInfo `protobuf:"bytes,8,opt,name=old_rootfs_info,json=oldRootfsInfo" json:"old_rootfs_info,omitempty"`
	NewRootfsInfo *PartitionInfo `protobuf:"bytes,9,opt,name=new_rootfs_info,json=newRootfsInfo" json:"new_rootfs_info,omitempty"`
	// old_image_info will only be present for delta images.
	OldImageInfo *ImageInfo `protobuf:"bytes,10,opt,name=old_image_info,json=oldImageInfo" json:"old_image_info,omitempty"`
	NewImageInfo *ImageInfo `protobuf:"bytes,11,opt,name=new_image_info,json=newImageInfo" json:"new_image_info,omitempty"`
	// The minor version, also referred as "delta version", of the payload.
	// Minor version 0 is full payload, everything else is delta payload.
	MinorVersion *uint32 `protobuf:"varint,12,opt,name=minor_version,json=minorVersion,def=0" json:"minor_version,omitempty"`
	// Only present in major version >= 2. List of partitions that will be
	// updated, in the order they will be updated. This field replaces the
	// |install_operations|, |kernel_install_operations| and the
	// |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
	// array can have more than two partitions if needed, and they are identified
	// by the partition name.
	Partitions []*PartitionUpdate `protobuf:"bytes,13,rep,name=partitions" json:"partitions,omitempty"`
	// The maximum timestamp of the OS allowed to apply this payload.
	// Can be used to prevent downgrading the OS.
	MaxTimestamp *int64 `protobuf:"varint,14,opt,name=max_timestamp,json=maxTimestamp" json:"max_timestamp,omitempty"`
	// Metadata related to all dynamic partitions.
	DynamicPartitionMetadata *DynamicPartitionMetadata `protobuf:"bytes,15,opt,name=dynamic_partition_metadata,json=dynamicPartitionMetadata" json:"dynamic_partition_metadata,omitempty"`
	XXX_unrecognized         []byte                    `json:"-"`
}

func (m *DeltaArchiveManifest) Reset()                    { *m = DeltaArchiveManifest{} }
func (m *DeltaArchiveManifest) String() string            { return proto.CompactTextString(m) }
func (*DeltaArchiveManifest) ProtoMessage()               {}
func (*DeltaArchiveManifest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

const Default_DeltaArchiveManifest_BlockSize uint32 = 4096
const Default_DeltaArchiveManifest_MinorVersion uint32 = 0

func (m *DeltaArchiveManifest) GetInstallOperations() []*InstallOperation {
	if m != nil {
		return m.InstallOperations
	}
	return nil
}

func (m *DeltaArchiveManifest) GetKernelInstallOperations() []*InstallOperation {
	if m != nil {
		return m.KernelInstallOperations
	}
	return nil
}

func (m *DeltaArchiveManifest) GetBlockSize() uint32 {
	if m != nil && m.BlockSize != nil {
		return *m.BlockSize
	}
	return Default_DeltaArchiveManifest_BlockSize
}

func (m *DeltaArchiveManifest) GetSignaturesOffset() uint64 {
	if m != nil && m.SignaturesOffset != nil {
		return *m.SignaturesOffset
	}
	return 0
}

func (m *DeltaArchiveManifest) GetSignaturesSize() uint64 {
	if m != nil && m.SignaturesSize != nil {
		return *m.SignaturesSize
	}
	return 0
}

func (m *DeltaArchiveManifest) GetOldKernelInfo() *PartitionInfo {
	if m != nil {
		return m.OldKernelInfo
	}
	return nil
}

func (m *DeltaArchiveManifest) GetNewKernelInfo() *PartitionInfo {
	if m != nil {
		return m.NewKernelInfo
	}
	return nil
}

func (m *DeltaArchiveManifest) GetOldRootfsInfo() *PartitionInfo {
	if m != nil {
		return m.OldRootfsInfo
	}
	return nil
}

func (m *DeltaArchiveManifest) GetNewRootfsInfo() *PartitionInfo {
	if m != nil {
		return m.NewRootfsInfo
	}
	return nil
}

func (m *DeltaArchiveManifest) GetOldImageInfo() *ImageInfo {
	if m != nil {
		return m.OldImageInfo
	}
	return nil
}

func (m *DeltaArchiveManifest) GetNewImageInfo() *ImageInfo {
	if m != nil {
		return m.NewImageInfo
	}
	return nil
}

func (m *DeltaArchiveManifest) GetMinorVersion() uint32 {
	if m != nil && m.MinorVersion != nil {
		return *m.MinorVersion
	}
	return Default_DeltaArchiveManifest_MinorVersion
}

func (m *DeltaArchiveManifest) GetPartitions() []*PartitionUpdate {
	if m != nil {
		return m.Partitions
	}
	return nil
}

func (m *DeltaArchiveManifest) GetMaxTimestamp() int64 {
	if m != nil && m.MaxTimestamp != nil {
		return *m.MaxTimestamp
	}
	return 0
}

func (m *DeltaArchiveManifest) GetDynamicPartitionMetadata() *DynamicPartitionMetadata {
	if m != nil {
		return m.DynamicPartitionMetadata
	}
	return nil
}

func init() {
	proto.RegisterType((*Extent)(nil), "chromeos_update_engine.Extent")
	proto.RegisterType((*Signatures)(nil), "chromeos_update_engine.Signatures")
	proto.RegisterType((*Signatures_Signature)(nil), "chromeos_update_engine.Signatures.Signature")
	proto.RegisterType((*PartitionInfo)(nil), "chromeos_update_engine.PartitionInfo")
	proto.RegisterType((*ImageInfo)(nil), "chromeos_update_engine.ImageInfo")
	proto.RegisterType((*InstallOperation)(nil), "chromeos_update_engine.InstallOperation")
	proto.RegisterType((*PartitionUpdate)(nil), "chromeos_update_engine.PartitionUpdate")
	proto.RegisterType((*DynamicPartitionGroup)(nil), "chromeos_update_engine.DynamicPartitionGroup")
	proto.RegisterType((*DynamicPartitionMetadata)(nil), "chromeos_update_engine.DynamicPartitionMetadata")
	proto.RegisterType((*DeltaArchiveManifest)(nil), "chromeos_update_engine.DeltaArchiveManifest")
	proto.RegisterEnum("chromeos_update_engine.InstallOperation_Type", InstallOperation_Type_name, InstallOperation_Type_value)
}

func init() { proto.RegisterFile("update_metadata.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1334 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x57, 0x6d, 0x6f, 0x1b, 0xc5,
	0x13, 0xff, 0x9f, 0xed, 0xc4, 0xbe, 0xb1, 0xef, 0x7c, 0xd9, 0x36, 0xff, 0x1e, 0x15, 0x94, 0xe0,
	0xd2, 0x26, 0x08, 0x88, 0x4a, 0x04, 0x45, 0x54, 0x42, 0x28, 0x0f, 0x4e, 0x62, 0x91, 0xe0, 0xb0,
	0x4e, 0x0b, 0xf4, 0xcd, 0x69, 0xe3, 0x5b, 0xc7, 0xa7, 0xde, 0xed, 0x9e, 0x6e, 0xd7, 0x4d, 0xd3,
	0xcf, 0xc0, 0xc7, 0xe0, 0x2d, 0x2f, 0xf8, 0x28, 0xbc, 0x44, 0xe2, 0xc3, 0xa0, 0xdd, 0x7b, 0x74,
	0x69, 0x54, 0x9b, 0x77, 0xbb, 0xbf, 0x99, 0xf9, 0xed, 0xcc, 0xde, 0xcc, 0xec, 0x1c, 0xac, 0xcf,
	0x62, 0x9f, 0x48, 0xea, 0x45, 0x54, 0x12, 0x9f, 0x48, 0xb2, 0x1d, 0x27, 0x5c, 0x72, 0xf4, 0xff,
	0xf1, 0x34, 0xe1, 0x11, 0xe5, 0xc2, 0xcb, 0xe4, 0x94, 0x5d, 0x06, 0x8c, 0xf6, 0x8e, 0x61, 0xb5,
	0xff, 0x4a, 0x52, 0x26, 0xd1, 0x87, 0xd0, 0x16, 0x92, 0x24, 0xd2, 0xbb, 0x08, 0xf9, 0xf8, 0x85,
	0x6b, 0x6c, 0x18, 0x5b, 0x0d, 0x0c, 0x1a, 0xda, 0x53, 0x08, 0xfa, 0x00, 0x80, 0xcd, 0xa2, 0x54,
	0x2c, 0xdc, 0x9a, 0x96, 0x9b, 0x6c, 0x16, 0x69, 0xa9, 0xe8, 0xfd, 0x69, 0x00, 0x8c, 0x82, 0x4b,
	0x46, 0xe4, 0x2c, 0xa1, 0x02, 0x9d, 0x00, 0x88, 0x62, 0xe7, 0x1a, 0x1b, 0xf5, 0xad, 0xf6, 0xce,
	0x67, 0xdb, 0x6f, 0xf7, 0x62, 0xbb, 0xb4, 0x2b, 0x97, 0xb8, 0x62, 0x7f, 0x77, 0x06, 0x66, 0x21,
	0x40, 0xef, 0x43, 0xf3, 0x25, 0x4d, 0x44, 0xc0, 0x99, 0xf6, 0xd2, 0xda, 0xab, 0xb9, 0x06, 0xce,
	0x21, 0x84, 0xa0, 0xa1, 0xe2, 0xd6, 0x0e, 0x76, 0xb0, 0x5e, 0xa3, 0xc7, 0x70, 0x67, 0xc6, 0x62,
	0xe2, 0xfb, 0xd4, 0xf7, 0x0a, 0x56, 0x4f, 0x04, 0xaf, 0xa9, 0x5b, 0xdf, 0x30, 0xb6, 0x9a, 0x78,
	0x3d, 0x17, 0x17, 0xa7, 0x8c, 0x82, 0xd7, 0xb4, 0xf7, 0x35, 0x58, 0x67, 0x24, 0x91, 0x81, 0x0c,
	0x38, 0x1b, 0xb0, 0x09, 0x57, 0xe4, 0xda, 0x2a, 0xbd, 0x1d, 0xbd, 0x56, 0xd8, 0x94, 0x88, 0x69,
	0x7e, 0xa0, 0x5a, 0xf7, 0xfe, 0x30, 0xc0, 0x1c, 0x44, 0xe4, 0x92, 0x6a, 0xab, 0xdb, 0xb0, 0x72,
	0xc1, 0x49, 0xe2, 0x6b, 0x33, 0x13, 0xa7, 0x1b, 0xe4, 0x40, 0xfd, 0x05, 0xbd, 0xd6, 0x66, 0x26,
	0x56, 0x4b, 0xe4, 0x42, 0x73, 0x3c, 0x25, 0x8c, 0xd1, 0x50, 0xbb, 0x65, 0xe2, 0x7c, 0xab, 0x24,
	0x79, 0xc8, 0x8d, 0x54, 0x92, 0x87, 0x7b, 0x1f, 0xac, 0x8b, 0x59, 0x10, 0xfa, 0x5e, 0x6e, 0xb9,
	0xa2, 0xe5, 0x1d, 0x0d, 0xee, 0x67, 0xe6, 0x85, 0x52, 0x4e, 0xb2, 0x5a, 0x51, 0x7a, 0x96, 0x62,
	0xbd, 0xbf, 0x1a, 0xe0, 0x0c, 0x98, 0x90, 0x24, 0x0c, 0x87, 0x31, 0x4d, 0x88, 0x0a, 0x1a, 0xed,
	0x42, 0x43, 0x5e, 0xc7, 0x2a, 0xe0, 0xda, 0x96, 0xbd, 0xf3, 0xf9, 0x4d, 0x1f, 0xf0, 0x4d, 0xbb,
	0xed, 0xf3, 0xeb, 0x98, 0x62, 0x6d, 0xaa, 0x12, 0x4b, 0x7d, 0x04, 0x8f, 0x4f, 0x26, 0x82, 0xca,
	0x2c, 0x71, 0x40, 0x41, 0x43, 0x8d, 0x14, 0x0a, 0x21, 0x65, 0x97, 0x72, 0xaa, 0x43, 0xcf, 0x14,
	0x4e, 0x34, 0x82, 0xbe, 0x83, 0xb6, 0x48, 0xc6, 0x1e, 0xd5, 0x89, 0x2a, 0xdc, 0x86, 0x4e, 0xa6,
	0x7b, 0x37, 0xf9, 0x92, 0xe6, 0x33, 0x06, 0x91, 0x8c, 0xd3, 0xa5, 0x50, 0xa9, 0xab, 0x08, 0xb2,
	0x03, 0x56, 0xd2, 0xd4, 0x15, 0xc9, 0xb8, 0xe4, 0xf7, 0x85, 0x2c, 0xf8, 0x57, 0x17, 0xe3, 0xf7,
	0x85, 0xac, 0xf0, 0x2b, 0x82, 0x8c, 0xbf, 0x99, 0xf2, 0xfb, 0x42, 0x66, 0xfc, 0x5b, 0xe0, 0xe8,
	0x00, 0xc5, 0x94, 0xec, 0x7c, 0xf5, 0xd8, 0xd3, 0xd9, 0xd2, 0xd2, 0xd9, 0x62, 0x2b, 0x7c, 0xa4,
	0xe1, 0x63, 0x22, 0xa6, 0xe8, 0x21, 0x74, 0x95, 0xa3, 0x55, 0x45, 0x53, 0x2b, 0x5a, 0x22, 0x19,
	0x97, 0x7a, 0xbd, 0xdf, 0x0d, 0x68, 0xa8, 0x2b, 0x46, 0x6d, 0x68, 0xe2, 0xfe, 0xd9, 0xc9, 0xee,
	0x7e, 0xdf, 0xf9, 0x1f, 0xb2, 0x01, 0xb2, 0x8d, 0xb7, 0xf7, 0xdc, 0x31, 0x50, 0x07, 0x1a, 0xa7,
	0xc3, 0x67, 0x7d, 0xa7, 0x76, 0xb7, 0xd6, 0x32, 0x90, 0x0d, 0xab, 0x7b, 0xa3, 0x83, 0xc1, 0xe1,
	0xa1, 0x53, 0xd7, 0xfb, 0x2e, 0xb4, 0x47, 0xc3, 0xa7, 0x78, 0xbf, 0xef, 0xed, 0x0f, 0xcf, 0x7e,
	0x71, 0x1a, 0x68, 0x0d, 0xac, 0x0c, 0xc8, 0xf4, 0x56, 0xaa, 0x8c, 0x3f, 0x3f, 0x77, 0x5a, 0xa8,
	0x05, 0x8d, 0xe7, 0x7d, 0x3c, 0x74, 0x56, 0xd5, 0xc1, 0x07, 0x83, 0xd1, 0xfe, 0x2e, 0x3e, 0x70,
	0x9a, 0xca, 0x72, 0x0f, 0x0f, 0xcf, 0x4f, 0x06, 0xb9, 0x25, 0xa0, 0x0e, 0xb4, 0xce, 0x9e, 0x1e,
	0x1e, 0xea, 0x9d, 0xd9, 0xfb, 0xbb, 0x09, 0xdd, 0xa2, 0x92, 0x9e, 0xea, 0xeb, 0x44, 0x0f, 0xc0,
	0x8e, 0x73, 0xc8, 0x63, 0x24, 0x4a, 0x93, 0xcc, 0xc4, 0x56, 0x81, 0xfe, 0x40, 0x22, 0x8a, 0x36,
	0xa1, 0x9b, 0xcc, 0x98, 0x17, 0x73, 0x21, 0x83, 0x34, 0xcb, 0x74, 0x0a, 0xb5, 0xb0, 0x9d, 0xcc,
	0xd8, 0x59, 0x89, 0xa2, 0x4f, 0xc0, 0xa9, 0x28, 0x79, 0x31, 0xc9, 0x72, 0xc9, 0xc4, 0xdd, 0x0a,
	0x7e, 0x46, 0xe4, 0x54, 0x71, 0x4e, 0x82, 0x90, 0x8a, 0x6b, 0x21, 0x69, 0xe4, 0xe9, 0x04, 0x4f,
	0xcb, 0xca, 0x2e, 0x61, 0x7d, 0xbd, 0x3e, 0xdc, 0x61, 0xf4, 0xca, 0x2b, 0xfd, 0x2c, 0xba, 0x87,
	0xbb, 0xf2, 0x1f, 0x5a, 0xda, 0x3a, 0xa3, 0x57, 0xc5, 0x35, 0x94, 0x0d, 0x6d, 0x04, 0x88, 0x87,
	0x7e, 0xe5, 0x94, 0x80, 0x4d, 0xb8, 0xae, 0xd1, 0xf6, 0xce, 0x83, 0x9b, 0x0e, 0x98, 0x6b, 0x4c,
	0xd8, 0xe1, 0xa1, 0x3f, 0xdf, 0xaa, 0x46, 0x80, 0xe6, 0x5d, 0xd7, 0xa4, 0xcd, 0xa5, 0x48, 0xab,
	0xee, 0x6a, 0xd2, 0x63, 0x00, 0x9e, 0xd7, 0xb8, 0x70, 0x5b, 0xfa, 0x0a, 0xb6, 0x16, 0x6d, 0x0a,
	0xb8, 0x62, 0x8b, 0xbe, 0x80, 0xdb, 0xd5, 0xaf, 0xc5, 0x63, 0x05, 0x93, 0x50, 0xa7, 0x7b, 0x0b,
	0xdf, 0xaa, 0xc8, 0x86, 0x99, 0x08, 0xfd, 0x08, 0xeb, 0xaa, 0x22, 0x3c, 0x99, 0x50, 0xea, 0xe9,
	0x82, 0x4a, 0x2b, 0xd6, 0x05, 0x1d, 0xd4, 0xbb, 0x0a, 0x16, 0x29, 0xe3, 0xf3, 0x84, 0xd2, 0x03,
	0x22, 0x49, 0xf6, 0xe8, 0x1d, 0x83, 0x53, 0x52, 0x66, 0x6c, 0xed, 0x85, 0xd8, 0xec, 0x9c, 0x2d,
	0x63, 0xda, 0x86, 0x5b, 0x25, 0x13, 0x09, 0x2f, 0x79, 0x12, 0xc8, 0x69, 0xe4, 0x76, 0x74, 0x5a,
	0xad, 0xe5, 0xca, 0xbb, 0xb9, 0x00, 0x7d, 0x0c, 0x76, 0xa9, 0x2f, 0x48, 0x28, 0x5d, 0x4b, 0x17,
	0x7a, 0x27, 0x57, 0x1d, 0x91, 0x50, 0xa2, 0x43, 0xe8, 0x4e, 0xe8, 0x78, 0x2e, 0x58, 0x7b, 0x21,
	0xf7, 0xac, 0x09, 0x1d, 0x57, 0xe2, 0xfc, 0x16, 0x40, 0xf1, 0x64, 0x14, 0xdd, 0x85, 0x28, 0xcc,
	0x09, 0xcd, 0x1a, 0x28, 0xba, 0x07, 0x6a, 0xe3, 0x25, 0x9c, 0x4b, 0xe1, 0x3a, 0xea, 0xcd, 0x7d,
	0x62, 0xec, 0xe0, 0xd6, 0x84, 0x8e, 0xb1, 0x82, 0x7a, 0x53, 0x58, 0x3f, 0xb8, 0x66, 0x24, 0x0a,
	0xc6, 0x45, 0xba, 0x1c, 0x25, 0x7c, 0x16, 0xab, 0xb7, 0xb1, 0x52, 0xd9, 0x7a, 0x5d, 0xbc, 0xa1,
	0xb5, 0xca, 0x1b, 0xba, 0x09, 0xdd, 0xf9, 0x5e, 0x20, 0xdc, 0xfa, 0x46, 0x5d, 0x15, 0xe4, 0x5c,
	0x33, 0x10, 0xbd, 0x5f, 0x0d, 0x70, 0xdf, 0x3c, 0xea, 0x34, 0x1b, 0x75, 0x50, 0x1f, 0x56, 0x2f,
	0xd5, 0xb1, 0xf9, 0xbc, 0x71, 0xe3, 0x73, 0xf5, 0x56, 0x67, 0x71, 0x66, 0xac, 0x1a, 0x89, 0x60,
	0x24, 0x16, 0x53, 0x2e, 0x3d, 0xca, 0xc8, 0x45, 0x48, 0xfd, 0xac, 0xe5, 0x74, 0x73, 0xbc, 0x9f,
	0xc2, 0xbd, 0xdf, 0x5a, 0x70, 0xfb, 0x80, 0x86, 0x92, 0xec, 0x26, 0xe3, 0x69, 0xf0, 0x92, 0x9e,
	0x12, 0x16, 0x4c, 0xa8, 0x90, 0xe8, 0x27, 0x40, 0x65, 0x6a, 0x17, 0x05, 0x63, 0x2c, 0x59, 0x30,
	0x6b, 0xc1, 0x1b, 0x88, 0x40, 0x3e, 0xbc, 0xf7, 0x82, 0x26, 0x8c, 0x86, 0xde, 0x5b, 0xf8, 0x6b,
	0x4b, 0xf2, 0xdf, 0x49, 0xa9, 0x06, 0xff, 0x3a, 0xe5, 0x3e, 0x80, 0x9e, 0xf3, 0xca, 0x19, 0xc9,
	0x7a, 0xd2, 0xf8, 0xf2, 0xd1, 0x37, 0x8f, 0xb1, 0xa9, 0x71, 0x35, 0x1d, 0xa1, 0x4f, 0x61, 0xad,
	0x1c, 0xd1, 0xf2, 0xe7, 0xbd, 0xa1, 0xbf, 0xaa, 0x53, 0x0a, 0xb2, 0x47, 0x7e, 0x13, 0xba, 0x15,
	0x65, 0x4d, 0x9b, 0xbe, 0xc3, 0x76, 0x09, 0x6b, 0xd6, 0x53, 0xe8, 0xaa, 0x66, 0x58, 0x04, 0xb9,
	0x6c, 0x27, 0xb4, 0x78, 0xe8, 0x7f, 0x9f, 0x85, 0x35, 0xe1, 0x8a, 0x4e, 0xb5, 0xc1, 0x2a, 0xdd,
	0x52, 0x3d, 0xd0, 0x62, 0xf4, 0x6a, 0x9e, 0x4e, 0x79, 0xa7, 0x2a, 0x61, 0x22, 0x52, 0xba, 0xd6,
	0xb2, 0xde, 0x61, 0x6d, 0x5c, 0xf5, 0xae, 0x4a, 0x67, 0x2e, 0xeb, 0x5d, 0x85, 0xee, 0x08, 0x6c,
	0xe5, 0x5d, 0xa0, 0x26, 0xcf, 0x94, 0x2d, 0x6d, 0x8d, 0x1f, 0xdd, 0x98, 0x11, 0xf9, 0x8c, 0x8a,
	0x3b, 0x3c, 0xf4, 0xcb, 0x89, 0xf5, 0x08, 0x6c, 0xe5, 0x57, 0x85, 0xa8, 0xbd, 0x30, 0x11, 0xa3,
	0x57, 0x25, 0xd1, 0x43, 0xb0, 0xa2, 0x80, 0xf1, 0xa4, 0x98, 0x3c, 0x3b, 0x69, 0xf7, 0x78, 0x84,
	0x3b, 0x1a, 0xcf, 0x86, 0x4f, 0x74, 0x04, 0x50, 0x54, 0xba, 0x70, 0x2d, 0x9d, 0xc7, 0x9b, 0xef,
	0xbc, 0x83, 0x74, 0x92, 0xc0, 0x15, 0x53, 0x35, 0xea, 0x46, 0xe4, 0x95, 0x27, 0x83, 0x88, 0x0a,
	0x49, 0xa2, 0x58, 0xf7, 0xcb, 0x3a, 0xee, 0x44, 0xe4, 0xd5, 0x79, 0x8e, 0x21, 0x06, 0x77, 0xfd,
	0xb4, 0x05, 0x54, 0xde, 0xc7, 0xfc, 0x8f, 0x29, 0x6b, 0x8f, 0x8f, 0x16, 0x6d, 0x1e, 0x79, 0xfb,
	0xc1, 0xae, 0x7f, 0x83, 0x64, 0xaf, 0x76, 0x5c, 0xff, 0x27, 0x00, 0x00, 0xff, 0xff, 0x83, 0x60,
	0xd1, 0x89, 0x99, 0x0d, 0x00, 0x00,
}
